# Phase II Integration Plan: Connecting Frontend, Backend, and Auth Server

**Status**: Ready for Integration
**Last Updated**: 2025-12-20
**Auth Server**: https://auth-server-production-cd0e.up.railway.app (Deployed on Railway)

---

## Table of Contents

1. [Architecture Overview](#architecture-overview)
2. [Current State Analysis](#current-state-analysis)
3. [Integration Steps](#integration-steps)
4. [Configuration Files](#configuration-files)
5. [CORS Setup](#cors-setup)
6. [Authentication Flow](#authentication-flow)
7. [Local Development Setup](#local-development-setup)
8. [Production Deployment](#production-deployment)
9. [Testing Strategy](#testing-strategy)
10. [Troubleshooting](#troubleshooting)

---

## Architecture Overview

```
┌─────────────────────────────────────────────────────────────────────┐
│                          PHASE II TODO APP                          │
└─────────────────────────────────────────────────────────────────────┘

┌──────────────────┐          ┌──────────────────┐          ┌──────────────────┐
│   FRONTEND       │          │   AUTH SERVER    │          │   BACKEND API    │
│   Next.js 16     │          │   Better Auth    │          │   FastAPI        │
│   Port: 3000     │          │   Port: 3001     │          │   Port: 8000     │
└──────────────────┘          └──────────────────┘          └──────────────────┘
        │                              │                              │
        │  1. Login Request            │                              │
        ├─────────────────────────────>│                              │
        │                              │                              │
        │  2. JWT Token (HttpOnly)     │                              │
        │<─────────────────────────────┤                              │
        │                              │                              │
        │  3. API Request + Cookie     │                              │
        ├──────────────────────────────────────────────────────────────>│
        │                              │                              │
        │                              │  4. Validate JWT Token       │
        │                              │<─────────────────────────────┤
        │                              │                              │
        │                              │  5. Token Valid ✓            │
        │                              │─────────────────────────────>│
        │                              │                              │
        │  6. Protected Data           │                              │
        │<──────────────────────────────────────────────────────────────┤
        │                              │                              │

┌──────────────────────────────────────────────────────────────────────┐
│                    SHARED DATABASE (Neon PostgreSQL)                 │
│  postgresql://neondb_owner:***@ep-***.us-east-1.aws.neon.tech       │
└──────────────────────────────────────────────────────────────────────┘
```

### Key Points:

1. **Auth Server**: Handles authentication (signup, login, logout, session)
2. **Backend API**: Handles business logic (task CRUD, validation)
3. **Frontend**: User interface, calls both auth server and backend
4. **Shared Database**: All services use the same Neon PostgreSQL database
5. **JWT Tokens**: Generated by auth server, validated by backend
6. **HttpOnly Cookies**: Tokens stored in browser cookies (XSS protection)

---

## Current State Analysis

### Auth Server (Deployed on Railway)
- **URL**: https://auth-server-production-cd0e.up.railway.app
- **Status**: Healthy ✓
- **Database**: Using SQLite locally (needs migration to PostgreSQL)
- **Endpoints**:
  - `POST /auth/sign-up` - Create account
  - `POST /auth/sign-in/email` - Login
  - `POST /auth/sign-out` - Logout
  - `GET /auth/get-session` - Get current user

**Issues to Fix**:
- Local .env uses SQLite (`sqlite://./auth.db`)
- Should use shared Neon PostgreSQL database
- JWT secret not synced with backend

### Backend API (FastAPI)
- **Location**: `E:\Hackathons-Panaversity\Hackathon-ii\MA-TODO\phase-2\backend`
- **Database**: Connected to Neon PostgreSQL
- **Endpoints**: `/api/auth/*` and `/api/tasks/*`
- **JWT Secret**: `dev-secret-replace-in-production-openssl-rand-hex-32`

**Issues to Fix**:
- Has its own `/api/auth` endpoints (conflicts with auth server)
- CORS needs to include auth server URL
- JWT secret must match auth server

### Frontend (Next.js)
- **Location**: `E:\Hackathons-Panaversity\Hackathon-ii\MA-TODO\phase-2\frontend`
- **Current API URL**: Points to Railway backend (production)
- **Auth Client**: Configured for local auth server (`localhost:3001`)

**Issues to Fix**:
- Missing unified API client for backend requests
- Environment variables point to different services
- Auth client URL doesn't match deployed auth server

---

## Integration Steps

### Step 1: Synchronize JWT Secrets

All services must use the **same JWT secret** for token compatibility.

**Generate a new secret**:
```bash
openssl rand -hex 32
```

**Update all three .env files** with the same secret:
- `phase-2/auth-server/.env` → `BETTER_AUTH_SECRET`
- `phase-2/backend/.env` → `JWT_SECRET`
- `phase-2/frontend/.env.local` → `BETTER_AUTH_SECRET`

### Step 2: Migrate Auth Server to PostgreSQL

**Update `phase-2/auth-server/.env`**:
```env
# Change from SQLite to PostgreSQL
DATABASE_URL=postgresql://neondb_owner:npg_8WSLxbOhQf1a@ep-solitary-morning-a4vdcuab-pooler.us-east-1.aws.neon.tech/neondb?sslmode=require
```

**Run migration**:
```bash
cd phase-2/auth-server
npm run migrate
```

### Step 3: Configure CORS for All Services

**Auth Server** (`phase-2/auth-server/.env`):
```env
CORS_ORIGINS=http://localhost:3000,http://127.0.0.1:3000,https://your-frontend.vercel.app
```

**Backend API** (`phase-2/backend/.env`):
```env
CORS_ORIGINS=http://localhost:3000,http://127.0.0.1:3000,https://your-frontend.vercel.app,https://auth-server-production-cd0e.up.railway.app
```

### Step 4: Update Frontend Environment Variables

**Create `phase-2/frontend/.env.local`**:
```env
# Auth Server URL (Railway deployment)
NEXT_PUBLIC_AUTH_URL=https://auth-server-production-cd0e.up.railway.app

# Backend API URL (Railway or local)
NEXT_PUBLIC_API_URL=http://localhost:8000

# JWT Secret (must match auth server)
BETTER_AUTH_SECRET=<same-secret-from-step-1>

# Environment
NEXT_PUBLIC_ENVIRONMENT=development
```

### Step 5: Create Frontend API Client

**Create `phase-2/frontend/src/lib/api.ts`**:
```typescript
/**
 * API Client for Backend Requests
 *
 * Centralized fetch wrapper with authentication and error handling
 */

const API_BASE_URL = process.env.NEXT_PUBLIC_API_URL || "http://localhost:8000";

export class APIError extends Error {
  constructor(
    message: string,
    public status: number,
    public details?: any
  ) {
    super(message);
    this.name = "APIError";
  }
}

export async function fetchAPI<T>(
  endpoint: string,
  options?: RequestInit
): Promise<T> {
  const url = `${API_BASE_URL}${endpoint}`;

  const response = await fetch(url, {
    ...options,
    credentials: "include", // Include HttpOnly cookies
    headers: {
      "Content-Type": "application/json",
      ...options?.headers,
    },
  });

  if (!response.ok) {
    const error = await response.json().catch(() => ({ detail: "Unknown error" }));
    throw new APIError(
      error.detail || `Request failed: ${response.statusText}`,
      response.status,
      error
    );
  }

  return response.json();
}

// Task API Functions
export interface Task {
  id: string;
  title: string;
  description: string | null;
  is_complete: boolean;
  user_id: string;
  created_at: string;
  updated_at: string;
}

export async function getTasks(params?: {
  is_complete?: boolean;
  limit?: number;
  offset?: number;
}): Promise<{ tasks: Task[]; total: number }> {
  const searchParams = new URLSearchParams();
  if (params?.is_complete !== undefined) {
    searchParams.set("is_complete", String(params.is_complete));
  }
  if (params?.limit) searchParams.set("limit", String(params.limit));
  if (params?.offset) searchParams.set("offset", String(params.offset));

  const query = searchParams.toString();
  return fetchAPI(`/api/tasks${query ? `?${query}` : ""}`);
}

export async function createTask(data: {
  title: string;
  description?: string;
}): Promise<Task> {
  return fetchAPI("/api/tasks", {
    method: "POST",
    body: JSON.stringify(data),
  });
}

export async function updateTask(
  taskId: string,
  data: Partial<{ title: string; description: string; is_complete: boolean }>
): Promise<Task> {
  return fetchAPI(`/api/tasks/${taskId}`, {
    method: "PATCH",
    body: JSON.stringify(data),
  });
}

export async function deleteTask(taskId: string): Promise<void> {
  return fetchAPI(`/api/tasks/${taskId}`, {
    method: "DELETE",
  });
}
```

### Step 6: Remove Duplicate Auth Endpoints from Backend

The backend currently has `/api/auth/*` endpoints that conflict with the auth server.

**Options**:
1. **Keep both** - Backend auth for local testing, auth server for production
2. **Remove backend auth** - Use auth server exclusively (recommended)

**Recommended**: Keep backend auth but disable in production by checking environment variable.

**Update `phase-2/backend/src/main.py`**:
```python
# Only include auth router in development
if os.getenv("ENVIRONMENT") == "development":
    app.include_router(auth.router)
```

### Step 7: Update Backend JWT Validation

Backend needs to validate tokens from auth server.

**Update `phase-2/backend/src/auth/dependencies.py`**:
```python
async def get_current_user(
    request: Request,
    session: Session = Depends(get_session)
) -> User:
    """Extract current user from JWT token (from auth server or backend)."""
    # Try to get token from cookie
    token = request.cookies.get("auth_token")

    # Fallback to Authorization header
    if not token:
        auth_header = request.headers.get("Authorization")
        if auth_header and auth_header.startswith("Bearer "):
            token = auth_header.replace("Bearer ", "")

    if not token:
        raise HTTPException(status_code=401, detail="Not authenticated")

    # Validate token
    try:
        payload = verify_token(token)
        user_id = UUID(payload.get("user_id"))
    except Exception:
        raise HTTPException(status_code=401, detail="Invalid token")

    # Fetch user from database
    user = session.get(User, user_id)
    if not user:
        raise HTTPException(status_code=401, detail="User not found")

    return user
```

---

## Configuration Files

### Auth Server `.env`
```env
# Database (MUST MATCH backend)
DATABASE_URL=postgresql://neondb_owner:npg_8WSLxbOhQf1a@ep-solitary-morning-a4vdcuab-pooler.us-east-1.aws.neon.tech/neondb?sslmode=require

# Better Auth
BETTER_AUTH_URL=https://auth-server-production-cd0e.up.railway.app
BETTER_AUTH_SECRET=<shared-secret>

# CORS
CORS_ORIGINS=http://localhost:3000,https://your-frontend.vercel.app

# Server
PORT=3001
NODE_ENV=production
```

### Backend `.env`
```env
# Database
DATABASE_URL=postgresql://neondb_owner:npg_8WSLxbOhQf1a@ep-solitary-morning-a4vdcuab-pooler.us-east-1.aws.neon.tech/neondb?sslmode=require

# JWT (MUST MATCH auth server)
JWT_SECRET=<shared-secret>
JWT_ALGORITHM=HS256
ACCESS_TOKEN_EXPIRE_MINUTES=15

# CORS
CORS_ORIGINS=http://localhost:3000,https://your-frontend.vercel.app,https://auth-server-production-cd0e.up.railway.app

# Environment
ENVIRONMENT=development
```

### Frontend `.env.local`
```env
# Auth Server (Railway)
NEXT_PUBLIC_AUTH_URL=https://auth-server-production-cd0e.up.railway.app

# Backend API (Railway or local)
NEXT_PUBLIC_API_URL=http://localhost:8000

# JWT Secret
BETTER_AUTH_SECRET=<shared-secret>

# Environment
NEXT_PUBLIC_ENVIRONMENT=development
```

---

## CORS Setup

### Why CORS Matters

Cross-Origin Resource Sharing (CORS) is critical because:
- Frontend (localhost:3000) calls auth server (localhost:3001 or Railway)
- Frontend calls backend API (localhost:8000 or Railway)
- Backend may call auth server for token validation

### CORS Configuration Checklist

- [ ] Auth server allows frontend origin
- [ ] Backend API allows frontend origin
- [ ] Backend API allows auth server origin (if needed)
- [ ] `credentials: true` enabled on all services
- [ ] Frontend uses `credentials: "include"` in fetch requests

### Testing CORS

```bash
# Test auth server CORS
curl -H "Origin: http://localhost:3000" \
     -H "Access-Control-Request-Method: POST" \
     -X OPTIONS \
     https://auth-server-production-cd0e.up.railway.app/auth/sign-in/email

# Should return:
# Access-Control-Allow-Origin: http://localhost:3000
# Access-Control-Allow-Credentials: true
```

---

## Authentication Flow

### 1. User Signup

```typescript
// Frontend (React Component)
import { signUp } from "@/lib/auth";

const handleSignup = async (data: { name: string; email: string; password: string }) => {
  try {
    const result = await signUp(data);
    // JWT token stored in HttpOnly cookie automatically
    router.push("/dashboard");
  } catch (error) {
    console.error("Signup failed:", error);
  }
};
```

**Flow**:
1. Frontend → `POST https://auth-server.railway.app/auth/sign-up`
2. Auth Server → Validates data, hashes password, creates user in PostgreSQL
3. Auth Server → Generates JWT token with user claims
4. Auth Server → Returns user data + sets `auth_token` HttpOnly cookie
5. Frontend → Stores user in state, redirects to dashboard

### 2. User Login

```typescript
// Frontend
import { signIn } from "@/lib/auth";

const handleLogin = async (data: { email: string; password: string }) => {
  try {
    const result = await signIn(data);
    router.push("/dashboard");
  } catch (error) {
    console.error("Login failed:", error);
  }
};
```

**Flow**:
1. Frontend → `POST https://auth-server.railway.app/auth/sign-in/email`
2. Auth Server → Validates credentials, verifies password
3. Auth Server → Generates JWT token
4. Auth Server → Returns user data + sets `auth_token` cookie
5. Frontend → Redirects to dashboard

### 3. Authenticated API Request

```typescript
// Frontend
import { getTasks } from "@/lib/api";

const fetchUserTasks = async () => {
  try {
    const { tasks } = await getTasks();
    // Cookie automatically included in request
  } catch (error) {
    console.error("Failed to fetch tasks:", error);
  }
};
```

**Flow**:
1. Frontend → `GET http://localhost:8000/api/tasks` (includes `auth_token` cookie)
2. Backend → Extracts token from cookie
3. Backend → Validates JWT signature using shared secret
4. Backend → Decodes user_id from token
5. Backend → Fetches user from PostgreSQL
6. Backend → Returns user's tasks
7. Frontend → Displays tasks

### 4. Token Expiration Handling

```typescript
// Frontend API client with token refresh
export async function fetchAPI<T>(endpoint: string, options?: RequestInit): Promise<T> {
  const response = await fetch(`${API_BASE_URL}${endpoint}`, {
    ...options,
    credentials: "include",
  });

  if (response.status === 401) {
    // Token expired - redirect to login
    window.location.href = "/login";
    throw new APIError("Session expired", 401);
  }

  if (!response.ok) {
    const error = await response.json();
    throw new APIError(error.detail, response.status);
  }

  return response.json();
}
```

---

## Local Development Setup

### Prerequisites
- Node.js 20+ (for auth server and frontend)
- Python 3.13+ with UV (for backend)
- PostgreSQL database (Neon account)

### Step-by-Step Setup

1. **Clone and Navigate**:
```bash
cd E:\Hackathons-Panaversity\Hackathon-ii\MA-TODO\phase-2
```

2. **Configure Environment Variables**:
   - Copy `.env.example` to `.env` in each service
   - Update with values from Configuration Files section

3. **Install Dependencies**:
```bash
# Auth Server
cd auth-server
npm install

# Backend
cd ../backend
uv sync

# Frontend
cd ../frontend
npm install  # or pnpm install
```

4. **Start Services** (in separate terminals):

**Terminal 1 - Auth Server**:
```bash
cd auth-server
npm run dev
# Runs on http://localhost:3001
```

**Terminal 2 - Backend API**:
```bash
cd backend
uv run uvicorn src.main:app --reload --port 8000
# Runs on http://localhost:8000
```

**Terminal 3 - Frontend**:
```bash
cd frontend
npm run dev
# Runs on http://localhost:3000
```

5. **Verify Health Checks**:
```bash
# Auth Server
curl http://localhost:3001/health

# Backend API
curl http://localhost:8000/health

# Frontend (open in browser)
http://localhost:3000
```

### Quick Start Script

**Create `phase-2/start-all.sh`** (or `.bat` for Windows):
```bash
#!/bin/bash

# Start all Phase II services

echo "Starting Auth Server..."
cd auth-server
npm run dev &
AUTH_PID=$!

echo "Starting Backend API..."
cd ../backend
uv run uvicorn src.main:app --reload --port 8000 &
BACKEND_PID=$!

echo "Starting Frontend..."
cd ../frontend
npm run dev &
FRONTEND_PID=$!

echo "All services started!"
echo "Auth Server: http://localhost:3001"
echo "Backend API: http://localhost:8000"
echo "Frontend: http://localhost:3000"

# Wait for Ctrl+C
trap "kill $AUTH_PID $BACKEND_PID $FRONTEND_PID; exit" SIGINT
wait
```

---

## Production Deployment

### Auth Server (Railway)
**Status**: Already deployed ✓
**URL**: https://auth-server-production-cd0e.up.railway.app

**Environment Variables** (set in Railway dashboard):
- `DATABASE_URL`: `${{Postgres.DATABASE_URL}}`
- `BETTER_AUTH_URL`: `https://auth-server-production-cd0e.up.railway.app`
- `BETTER_AUTH_SECRET`: (use Railway secrets)
- `CORS_ORIGINS`: `https://your-frontend.vercel.app,http://localhost:3000`

### Backend API (Railway/Render)
**Deploy to Railway**:
1. Create new Railway project
2. Connect GitHub repo
3. Set root directory to `phase-2/backend`
4. Set environment variables
5. Deploy

**Environment Variables**:
- `DATABASE_URL`: Same Neon PostgreSQL URL
- `JWT_SECRET`: Same as `BETTER_AUTH_SECRET`
- `CORS_ORIGINS`: Include frontend and auth server URLs
- `ENVIRONMENT`: `production`

### Frontend (Vercel)
**Deploy to Vercel**:
1. Connect GitHub repo
2. Set root directory to `phase-2/frontend`
3. Set environment variables
4. Deploy

**Environment Variables**:
- `NEXT_PUBLIC_AUTH_URL`: Auth server Railway URL
- `NEXT_PUBLIC_API_URL`: Backend Railway URL
- `BETTER_AUTH_SECRET`: Same secret (for Next.js server-side)

---

## Testing Strategy

### 1. Unit Tests

**Auth Server**:
```bash
cd auth-server
npm test  # (if tests exist)
```

**Backend**:
```bash
cd backend
uv run pytest
```

**Frontend**:
```bash
cd frontend
npm test
```

### 2. Integration Tests

**Test Authentication Flow**:
```bash
# 1. Sign up
curl -X POST http://localhost:3001/auth/sign-up \
  -H "Content-Type: application/json" \
  -d '{"name":"Test User","email":"test@example.com","password":"password123"}' \
  -c cookies.txt

# 2. Get session
curl http://localhost:3001/auth/get-session -b cookies.txt

# 3. Call protected backend endpoint
curl http://localhost:8000/api/tasks -b cookies.txt

# 4. Logout
curl -X POST http://localhost:3001/auth/sign-out -b cookies.txt
```

### 3. End-to-End Tests (Playwright)

**Frontend E2E**:
```bash
cd frontend
npm run test:e2e
```

**Sample test** (`frontend/tests/e2e/auth-flow.spec.ts`):
```typescript
import { test, expect } from "@playwright/test";

test("complete authentication flow", async ({ page }) => {
  // Sign up
  await page.goto("http://localhost:3000/signup");
  await page.fill('[name="name"]', "Test User");
  await page.fill('[name="email"]', "test@example.com");
  await page.fill('[name="password"]', "password123");
  await page.click('button[type="submit"]');

  // Should redirect to dashboard
  await expect(page).toHaveURL(/.*dashboard/);

  // Create a task
  await page.click("text=Add Task");
  await page.fill('[name="title"]', "Test Task");
  await page.click('button:has-text("Save")');

  // Verify task appears
  await expect(page.locator("text=Test Task")).toBeVisible();

  // Logout
  await page.click("text=Logout");
  await expect(page).toHaveURL(/.*login/);
});
```

---

## Troubleshooting

### Issue 1: CORS Errors

**Symptom**: Browser console shows `CORS policy: No 'Access-Control-Allow-Origin' header`

**Solution**:
1. Verify `CORS_ORIGINS` in auth server and backend `.env`
2. Check frontend is using `credentials: "include"`
3. Ensure auth server and backend return `Access-Control-Allow-Credentials: true`

**Debug**:
```bash
# Check CORS headers
curl -v -H "Origin: http://localhost:3000" http://localhost:3001/health
```

### Issue 2: Token Not Included in Requests

**Symptom**: Backend returns 401 Unauthorized even after login

**Solution**:
1. Check browser cookies (DevTools → Application → Cookies)
2. Verify `auth_token` cookie exists and has correct domain
3. Ensure fetch uses `credentials: "include"`
4. Check `httpOnly`, `secure`, `sameSite` cookie settings

**Debug**:
```javascript
// In browser console
document.cookie  // Should show auth_token
```

### Issue 3: JWT Signature Mismatch

**Symptom**: Backend logs show "Invalid token signature"

**Solution**:
1. Verify `BETTER_AUTH_SECRET` (auth server) matches `JWT_SECRET` (backend)
2. Check both use same algorithm (HS256)
3. Regenerate secret and update both services

**Verify**:
```bash
# Decode JWT token (without verification)
echo "eyJhbGc..." | base64 -d
```

### Issue 4: Database Connection Errors

**Symptom**: Auth server or backend fails to start with database error

**Solution**:
1. Verify `DATABASE_URL` is identical in both `.env` files
2. Check Neon PostgreSQL is running and accessible
3. Test connection with `psql` or database client
4. Ensure `?sslmode=require` is in connection string

**Test**:
```bash
# Test PostgreSQL connection
psql "postgresql://neondb_owner:***@ep-***.us-east-1.aws.neon.tech/neondb?sslmode=require"
```

### Issue 5: Port Already in Use

**Symptom**: `Error: listen EADDRINUSE: address already in use :::3001`

**Solution**:
```bash
# Windows
netstat -ano | findstr :3001
taskkill /PID <PID> /F

# Linux/Mac
lsof -ti:3001 | xargs kill -9
```

---

## Next Steps

1. [ ] Update all `.env` files with synchronized JWT secrets
2. [ ] Migrate auth server from SQLite to PostgreSQL
3. [ ] Create frontend API client (`src/lib/api.ts`)
4. [ ] Update CORS configurations
5. [ ] Test authentication flow locally
6. [ ] Deploy backend to Railway
7. [ ] Deploy frontend to Vercel
8. [ ] Run end-to-end tests
9. [ ] Update production environment variables
10. [ ] Monitor logs for errors

---

## Support and Resources

- **Auth Server Repo**: `phase-2/auth-server`
- **Backend Repo**: `phase-2/backend`
- **Frontend Repo**: `phase-2/frontend`
- **Better Auth Docs**: https://better-auth.com
- **FastAPI Docs**: https://fastapi.tiangolo.com
- **Next.js Docs**: https://nextjs.org/docs

For issues, check:
1. This integration plan
2. Individual service `CLAUDE.md` files
3. Service-specific `README.md` files
4. Railway/Vercel deployment logs
